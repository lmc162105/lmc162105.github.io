# 

# 一、golang脑图

![img](https://camo.githubusercontent.com/14ae0ae04052757a75e9f3790912ca4fde5d606e4c02d3f96c5f985fed3b4a56/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f626169546563682f696d6167652f2545352539302538452545372541422541462545362538382539302545392539352542462545382542372541462545372542412542462e706e67)

截至目前，golang后端开发的基础学习阶段已经结束，后端开发四大件已经基本接触完成，但既然是基础，就证明还没有一个深刻的印象。

因此，自25.04.17日到4.30为止，要进行为期两周的特殊训练，在此期间，每天要进行4道算法题的设计，一个中等体量的开源项目实战，以及对go语言圣经的深度学习。

别忘了中间件的使用、go语言标准库和go八股文的学习。

***

# 二、go语言圣经

## 1.程序结构

### 1.1变量

var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并设置变量的初始值。一般语法如下

```shell
var 变量名称 变量类型 = 表达式
```

也可以在一个声明语句中同时声明一组变量，如果省略每个变量的类型，将可以声明多个类型不同的变量

```shell
var a, b, c = true, 2.3, "four" //bool,float64,string
```



#### 1.1.1简短声明变量

在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化`局部变量`。

它以“名字  := 表达式“的形式声明变量，变量的类型根据表达式来自动推导。

```shell
str := "i am a string"
num := 10
t := 2.3
```

因为简洁和灵活的特点，简短变量声明被管饭的应用与大部分的局部变量的声明和初始化。var形式的声明语句往往是用于需要显式指定变量类型的地方，后者变量稍后会被重新赋值而初始值无关紧要的地方。

> 请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作

#### 1.1.2指针

一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。

#### 1.1.3.new函数

另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T

***

## 2.基础数据类型

Go语言将数据类型分成四类：基础类型、复合类型、引用类型和接口类型。

引用类型包括指针、切片、map字典、函数、channel。



***

## 3.复合数据类型

### 3.1.slice

slice代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作`[]T`，其中T代表了slice中元素的类型

数组和slice之间有着紧密的联系，一个slice是一个轻量级的数据结构。

一个slice由三个部分组成：指针、长度和容量。

多个slice之间可以共享底层的数据。

![img](https://gopl-zh.github.io/images/ch4-01.png)

值得注意的是，slice不同于数组，slice之间不能比较，因此我们不能使用==操作符来判断两个slice之间是否含有全部相等元素。不过标准库提供了高度优化的`bytes.Equal`函数来判断两个字节型slice是否相等([]byte)。

如果你需要测试一个slice是否为空，使用len（）==0来判断，而不应该用s==nil来判断。

内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。

```shell
make([]T, len)
make([]T, len, cap) //same as make([]T, cap)[:len]
```

#### 3.1.1.append函数

内置的append函数用于想slice追加元素

### 3.2Map

哈希表是一巧妙并且实用的数据结构。它是一个无序的key/value对的集合。

内置的make函数可以创建一个map：

```shell
ages := make(map[string]int)
```

因此，另一种创建空的map的表达式是`map[string]int{}`

使用内置的delete函数可以删除元素：

```shell
delete(ages, "alice")
```

所有的这些操作都是安全的，即使这些元素不在map中也没有关系；如果一个查找失败将返回value烈性对应的零值。

但map中的元素并不是一个变量，因此我们不能对map的元素进行取之操作。

禁止对map元素去值得原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而导致之前地址无效。

mpa类型的零值是nil，也就是没有引用任何哈希表。map上的大部分操作都可以安全工作在nil值的map上。

和slice一样，map之间也不能进行相等比较，唯一的例外是和nil进行比较。

### 3.3.结构体

结构体是一种聚合的书籍类型，是由零个或多个人一类型的值聚合成的实体。

结构体的零值是每个成员都是零值。

如果结构体没有任何成员的话即时空结构体，写作`struct{}`.

如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回。如果要在函数你不修改结构体成员的话，用指针传入是必须的。

如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==后!=运算符进行比较。

Go语言有一个特性让我们只声明一个成员对应的数据类型而不指定成员的名字，这类成员就叫匿名成员。

### 3.4.JSON

javascript对象表示法是一种用于发送和接收结构化信息的标准协议。

许多web服务都提供json借口，通过HTTP借口json格式请求并返回json格式的信息。

***

## 4.函数

> 函数参数的传递方式

1.值传递

2.引用传递

不管是只床底还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝

一般来说，地址拷贝的效率更高。

### 4.1函数声明

函数声明包括函数名、形式参数列表、返回值列表。其中返回值列表可以省略。

### 4.2递归

函数是可以递归的，这意味着函数可以直接或者间接的点用自身。

### 4.3多返回值

在go中，一个函数可以返回多个值。

调用多返回值函数时，返回给调用者的是一组值，调用者必须显示的将这些值分配给这些变量。

如果某个值不被使用，则可以将其分配给blank identifier"_"。

如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数，这称之为bare return。

### 4.4匿名函数

拥有函数名的函数只能在包级语法块中被声明，，通过函数字面量，我们可以绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于func关键字后面有没有函数名。

当匿名函数需要别递归调用时，我们必须首先声明一个变量，再将匿名函数赋值给这个变量。

### 4.5.可变参数

参数数量可变的函数被称为可变参数函数。

声明可变参数函数是，需要在参数列表的最后一个参数类型之前加上一个省略符号“...“，者表示该函数会接受任意数量的该类型参数。

```shell
func sum(vals ...int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}

```

### 4.6.Deferred函数

在函数只能够，程序员经常需要创建资源，为了在函数执行完毕后，及时的释放资源，Go的设计者提供了defer

你可以在一个函数中执行多条defer语句，他们的执行顺序与声明顺序相反。

> defer细节说明

1.当go执行到一个defer时，不会立即执行defer后的语句，ershijiangdefer后的语句压到一个栈中；

2.当函数执行完毕后，再从defer栈中依次从栈顶取出语句执行；

3.在defer将语句压入到栈中时，也会将相关的值拷贝入栈。

defer的主要价值是在，当语句执行完毕后，可以及时的释放函数创建的资源，当函数完毕后，系统会以此从defer栈中取出语句，关闭资源。

### 4.7.Panic异常

一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer机制）。随后，程序崩溃并输出日志信息。

不是所有的panic异常都来自于运行时，直接调用内置的panic函数也会引发panic异常。

由于panic会引起程序的崩溃，因此panic一般用于严重错误。

### 4.8.Recover捕获异常

通常来说，不应该对panic异常做任何处理，但有时我们可以从异常中恢复，至少我们可以在程序崩溃前做一些操作。

如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了painc异常，recover会使程序从painc中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。

***

## 5.方法

Golang中的方法是作用在指定的数据类型上，因此自定义类型都可以有方法。

### 5.1.方法声明

在函数声明时，在其名字之前放上一个变量，即是一个方法。

在go语言中，我们并不会像其他语言一样使用this或self作为接收器，我们可以任意的选择接收器的名字。

```shell
func(reciver type) methodName(实参列表)（返回值列表）{...}
```

1.结构体类型是值类型，遵守值类型的传递机制；

2.若希望在方法中修改结构体变量的值，可以通过结构体指针的方式；

3.再通过一个变量去调用方法时，其调用机制和函数一样；

4.变量调用方法时，该变量本身也会作为一个参数传递到方法。



> 方法和函数的区别

1.调用方式不一样

​	函数的调用方式：函数名(实参列表)

​	方法的调用方式：变量名.方法名(实参列表)

2.对于普通函数，接受者为值类型时，不能将指针类型的数据直接传递；

3.对于方法，接受者作为值类型时，可以直接使用指针类型的变量调用。

### 5.2基于指针对象的方法

当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免这种默认的拷贝，这种情况下就需要用到指针了。

```shell
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}

```

这个方法的名字是`(*piont).ScanleBy`,这里的括号是必须的。

在现实的程序里，一半约定如果Point这个泪有一个指针作为接收器的方法，那么所有的point的方法都必须有一个指针接收器

在每一个合法的方式调用表达式中，也就是下面这三种情况里的任意一种情况都是可以的：

1.几首期的实际参数和其形式参数是相同的类型，比如两者都是类型T或者*T；

2.接收器实参是类型T，但接收器的形参是类型*T，这种情况下表一起会隐式的为我们取变量的地址；

3.接收器实参是类型*T，形参是类型T，编译器会隐式的为我们解引用，取到指针指向的实际变量。

#### 5.2.1.nil也是一个合法的接收器类型

就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice

### 5.3.封装

一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是main想对象编程最关键的一个方面。

> 封装的优点

首先，因为调用方不能直接修改对象的变量值，七只需要关注少量的语句并且只要弄懂少量变量的可能的值即可；

其次，隐藏实现的细节，可以防止调用方以来那些可能变化的具体实现，这样是设计包的程序员在不破坏对外的api情况下能得到更大的自由；

最后，是阻止了外部调用方对对象内部的值任意的进行修改。

***

## 6.接口

接口类型是对其他类型行为的抽象和概括；因为接口类型不会喝特定的实现细节绑定在一起，通过这种抽象的方式我们可以让函数更加的灵活和更具有适应能力。

> 细节：
>
> 1.接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型变量；
>
> 2.接口中的所有方法都没有方法体，即都是未实现的方法；
>
> 3.在go中，一个自定义类型需要讲某个接口的所有方法都实现，即这个自定义类型实现了该接口；
>
> 4.一个自定义类型只有实现了某个接口，才能将该自定义类型的实例赋给接口；
>
> 5.只要是自定义数据类型，就可以实现接口；
>
> 6.一个自定义类型可以实现多个接口；
>
> 7.golang借口中不能有任何变量；
>
> 8.一个接口可以继承多个别的接口，这时实现该接口，需将全体实现；
>
> 9.interface默认是一个指针类型，如果没有初始化就使用，则输出nil
>
> 10.空接口`interface{}`没有任何方法，所以所有类型都实现了空接口，即我们可以把任何一个变量赋给空接口。

### 6.1接口约定

接口类型是一种抽象的类型。

接口类型可以定义一组方法，但是这些方法不需要实现，并且接口不能包含任何的变量。

### 6.2接口类型

基本语法：

```shell
type 接口名 interface {
	method1 (参数列表) (返回值列表)
}
```

1.接口里所有的方法都没有方法体，即接口的方法都是没有实现的方法，接口体现了程序设计的多态和高内聚低耦合的思想；

2.golang中的接口，不需要显式的实现，只需要一个变量，含有接口中的所有的方法，那么这个变量就实现这个接口。

### 6.3.实现接口的条件

一个类型如果拥有一个接口所需要的所有方法，那么这个类型就实现了这个接口。

接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。

### 6.4类型断言

类型断言时一个使用在接口之上的操作。语法上他看起来像x.(T)被称为断言类型，这里的x表示一个就扣的类型和T表示一个类型。

这里有两种可能，第一种，如果断言的类型T是一个具体类型，然后类型断言检查X的动态类型是否和T相同，如果这个检查成功了，类型断言的结果是x的动态值，当然他的类型是T。如果检查时报，接下来的操作会抛出panic

***

## 7.Go routines和Channels

并发程序指同时进行多个任务的程序，随着硬件的发展，并发程序变得越来越重要。

### 7.1.Go routines

在go语言中，每一个并发的执行单元叫做一个goroutine。

> 进程和线程的区别

1.进程就是陈古仔操作系统中的一次执行过程模式系统进行资源分配和调度的基本单位；

2.线城市进程的一个执行实例，是执行程序的最小单元，它是比进程更小的能独立运行的基本单位；

3.一个进程可以创建和销毁多个线程，同一个进程中的多个线程可以并发执行；

4.一个程序至少有一个进程，一个进程至少有一个线程。



> 并发和并行

1.多线程程序在单核上运行就是并发；

2.多线程程序在多核上运行就是并行。



> Go协程和主线程

1.go主线程：在一个go线程上，可以起多个协程

2.go协程的特点：

​	1)有独立的栈空间；

​	2)共享程序堆空间；

​	3)调度由用户控制；

​	4)协程是轻量级的线程。

若主线程退出，协程即使没有实行完毕，也会退出。



> goroutine-MPG模式

1.主线程是一个物理线程，直接作用在CPU中，是重量级的，耗cpu；

2.写成诗主线程开始的，是轻量级的线程，是逻辑态。

M：代表真正的内核OS线程，和POSIX的thread差不多；

P：代表一个go routine，它有自己的栈，用于调度；

M：代表调度的上下文，可将它看作局部调度器，是实现N:1到N:M的关键。

### 7.2.Channel

> 不同的goroutine之间如何通讯？

如果说goroutine是go语言的并发体的话，那么channel则是他们之间的通信机制。

1.channel 本质就是一个数据结构-队列

2.数据是先进先出的

3.线程安全，多routine访问时，不需要加锁



使用内置的make函数，我们可以创建一个channel：

```shell
ch := make(chan int)
```

说明：channel是引用类型，并且必须初始化后才能使用

和map类似，channel也对应一个make创建的递呈数据结构的引用。当我们复制一个hannel或用于函数参数传递时，我们只是拷贝了一个channel引用。

一个channel有发送和接收两个主要操作，都是通信行为。

```shell
ch <- x  // a send statement
x = <-ch // a receive expression in an assignment statement
<-ch     
```



> 注意事项

1.channel中只能存放指定的数据类型

2.channel的数据放满后，就不能在放入了；

3.如果从满channel中取出数据后，可以继续放入；

4.在没有使用协程的情况下，channel中数据取完了再取，会报deadlock；

5.channel可以声明为只读或只写性质，默认情况下，管道是双向的

```shell
#只写
var 变量名 chan<-类型
#只读
var 变量名 <-chan 类型
```

6.使用select可以解决从管道中取数据的阻塞问题；

7.goroutine中使用recover，解决写成中出现的panic导致程序崩溃问题。

#### 7.2.1.channel的关闭

使用内置的close函数就可以关闭一个channel，当channel关闭后，就不能在想channel写数据了，但仍可以从该channel中读取数据。

#### 7.2.2.不带缓存的channel

一个基于无缓存channel的发送操作将导致发送者goroutine阻塞成功，直到另一个goroutine在相同的channel上执行接受操作。

也就是说，如果编译器运行时，发现一个管道只有写操作，而没有读操作，则该管道会阻塞，而写操作和读操作的频率不一致，无所谓。
